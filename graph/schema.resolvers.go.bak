// package graph

// // This file will be automatically regenerated based on the schema, any resolver implementations
// // will be copied through when generating and any unknown code will be moved to the end.
// // Code generated by github.com/99designs/gqlgen version v0.17.66

// import (
// 	"context"
// 	"fmt"
// 	"property_backend/graph/model"
// 	"time"
// )

// // Login is the resolver for the login field.
// func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Token, error) {
// 	// Load environment variables
// 	err := godotenv.Load()
// 	if err != nil {
// 		log.Printf("Failed to load .env file: %v", err)
// 		return nil, fmt.Errorf("internal server error")
// 	}

// 	// Fetch JWT secret key
// 	secret := os.Getenv("JWT_SECRET")
// 	if secret == "" {
// 		log.Println("JWT_SECRET is missing in .env file")
// 		return nil, fmt.Errorf("internal server error")
// 	}

// 	// Simulated database lookup (replace with actual DB check)
// 	if email != "test@example.com" || password != "password" {
// 		return nil, fmt.Errorf("invalid credentials")
// 	}

// 	// Create JWT token with claims
// 	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
// 		"email": email,
// 		"role":  "user",
// 		"iat":   time.Now().Unix(),
// 		"exp":   time.Now().Add(time.Hour * 24).Unix(), // Token expires in 24 hours
// 	})

// 	// Sign the token
// 	tokenStr, err := token.SignedString([]byte(secret))
// 	if err != nil {
// 		log.Printf("Error signing token: %v", err)
// 		return nil, fmt.Errorf("failed to generate token")
// 	}

// 	log.Printf("Generated Token: %s", tokenStr) // Debugging

// 	return &model.Token{Token: tokenStr}, nil
// }

// // CreateProperty is the resolver for the createProperty field.
// func (r *mutationResolver) CreateProperty(ctx context.Context, input model.PropertyInput) (*model.Property, error) {
// 	user := ctx.Value(userKey).(jwt.MapClaims)
// 	if user["role"] != "vendor" {
// 		return nil, fmt.Errorf("forbidden: only vendors can create properties")
// 	}

// 	conn := db.GetConn()
// 	var id int
// 	err := conn.QueryRow(context.Background(),
// 		"INSERT INTO properties (address, price, vendor_name, description) VALUES ($1, $2, $3, $4) RETURNING id",
// 		input.Address, input.Price, input.VendorName, input.Description).Scan(&id)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to create property: %v", err)
// 	}

// 	return &model.Property{
// 		ID:          fmt.Sprint(id),
// 		Address:     input.Address,
// 		Price:       input.Price,
// 		VendorName:  input.VendorName,
// 		Description: input.Description,
// 	}, nil
// }

// // UpdateProperty is the resolver for the updateProperty field.
// func (r *mutationResolver) UpdateProperty(ctx context.Context, id string, input model.PropertyInput) (*model.Property, error) {
// 	user := ctx.Value(userKey).(jwt.MapClaims)
// 	if user["role"] != "vendor" {
// 		return nil, fmt.Errorf("forbidden: only vendors can update properties")
// 	}

// 	conn := db.GetConn()
// 	_, err := conn.Exec(context.Background(),
// 		"UPDATE properties SET address = $1, price = $2, vendor_name = $3, description = $4 WHERE id = $5",
// 		input.Address, input.Price, input.VendorName, input.Description, id)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update property: %v", err)
// 	}

// 	return &model.Property{
// 		ID:          id,
// 		Address:     input.Address,
// 		Price:       input.Price,
// 		VendorName:  input.VendorName,
// 		Description: input.Description,
// 	}, nil
// }

// // DeleteProperty is the resolver for the deleteProperty field.
// func (r *mutationResolver) DeleteProperty(ctx context.Context, id string) (bool, error) {
// 	user := ctx.Value(userKey).(jwt.MapClaims)
// 	if user["role"] != "vendor" {
// 		return false, fmt.Errorf("forbidden: only vendors can delete properties")
// 	}

// 	conn := db.GetConn()
// 	result, err := conn.Exec(context.Background(), "DELETE FROM properties WHERE id = $1", id)
// 	if err != nil {
// 		return false, fmt.Errorf("failed to delete property: %v", err)
// 	}

// 	rowsAffected := result.RowsAffected() // Fixed: Only one return value
// 	if rowsAffected == 0 {
// 		return false, fmt.Errorf("property with id %s not found", id)
// 	}

// 	return true, nil
// }

// // VerifyVendor is the resolver for the verifyVendor field.
// func (r *mutationResolver) VerifyVendor(ctx context.Context, input model.VendorInput) (*model.VerificationResult, error) {
// 	user := ctx.Value(userKey).(jwt.MapClaims)
// 	if user["role"] != "admin" {
// 		return nil, fmt.Errorf("forbidden: only admins can verify vendors")
// 	}
// 	return &model.VerificationResult{Status: "verified"}, nil
// }

// // GetProfile is the resolver for the getProfile field.
// func (r *queryResolver) GetProfile(ctx context.Context) (*model.User, error) {
// 	user := ctx.Value(userKey).(jwt.MapClaims)
// 	return &model.User{
// 		ID:    "1",
// 		Email: user["email"].(string),
// 		Role:  user["role"].(string),
// 	}, nil
// }

// // ListProperties is the resolver for the listProperties field.
// func (r *queryResolver) ListProperties(ctx context.Context) ([]*model.Property, error) {
// 	conn := db.GetConn()
// 	rows, err := conn.Query(context.Background(), "SELECT id, address, price, vendor_name, description FROM properties")
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to list properties: %v", err)
// 	}
// 	defer rows.Close()

// 	var properties []*model.Property
// 	for rows.Next() {
// 		var p model.Property
// 		err := rows.Scan(&p.ID, &p.Address, &p.Price, &p.VendorName, &p.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan property: %v", err)
// 		}
// 		properties = append(properties, &p)
// 	}
// 	return properties, nil
// }

// // GetProperty is the resolver for the getProperty field.
// func (r *queryResolver) GetProperty(ctx context.Context, id string) (*model.Property, error) {
// 	conn := db.GetConn()
// 	var p model.Property
// 	err := conn.QueryRow(context.Background(),
// 		"SELECT id, address, price, vendor_name, description FROM properties WHERE id = $1", id).
// 		Scan(&p.ID, &p.Address, &p.Price, &p.VendorName, &p.Description)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get property: %v", err)
// 	}
// 	return &p, nil
// }

// // SimilarProperties is the resolver for the similarProperties field.
// func (r *queryResolver) SimilarProperties(ctx context.Context, description string) ([]*model.Property, error) {
// 	properties, err := r.ListProperties(ctx)
// 	if err != nil {
// 		return nil, err
// 	}

// 	inputEmbedding := embedding.GenerateEmbedding(description)
// 	type result struct {
// 		Property *model.Property
// 		Score    float64
// 	}

// 	var results []result
// 	for _, p := range properties {
// 		emb := embedding.GenerateEmbedding(p.Description)
// 		score := embedding.CosineSimilarity(inputEmbedding, emb)
// 		results = append(results, result{Property: p, Score: score})
// 	}

// 	sort.Slice(results, func(i, j int) bool { return results[i].Score > results[j].Score })
// 	var similar []*model.Property
// 	for i := 0; i < len(results) && i < 3; i++ {
// 		similar = append(similar, results[i].Property)
// 	}
// 	return similar, nil
// }

// // GetLeadScore is the resolver for the getLeadScore field.
// func (r *queryResolver) GetLeadScore(ctx context.Context, input model.LeadInput) (*model.LeadScore, error) {
// 	score := 0.0
// 	if input.PropertyPrice > 100000 {
// 		score += 0.5
// 	}
// 	if input.Location == "downtown" {
// 		score += 0.3
// 	}
// 	return &model.LeadScore{Score: score}, nil
// }

// // Mutation returns MutationResolver implementation.
// func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// // Query returns QueryResolver implementation.
// func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// type mutationResolver struct{ *Resolver }
// type queryResolver struct{ *Resolver }
